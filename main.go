package main

/*
$GOARCH
	The execution architecture (arm, amd64, etc.)
$GOOS
	The execution operating system (linux, windows, etc.)
$GOFILE
	The base name of the file.
$GOLINE
	The line number of the directive in the source file.
$GOPACKAGE
	The name of the package of the file containing the directive.
$DOLLAR
	A dollar sign.

https://golang.org/cmd/go/#hdr-Generate_Go_files_by_processing_source
*/

import (
	"bufio"
	"bytes"
	"fmt"
	"log"
	"os"
	"strings"

	"github.com/mkideal/cli"
)

type argT struct {
	Inputs  []string `cli:"I" usage:"Input files"`
	Output  string   `cli:"O" usage:"Output file"`
	Package string   `cli:"P" usage:"Go Package"`
}

func main() {
	args := new(argT)
	cli.Run(args, func(ctx *cli.Context) error {
		inputs := args.Inputs
		if len(inputs) == 0 {
			ctx.Color().Red(ctx.Usage())
			return nil
		}
		source := ""
		output := args.Output
		if output == "" {
			if len(ctx.Args()) < 1 && os.Getenv("GOFILE") == "" {
				ctx.Color().Red(ctx.Usage())
				return nil
			} else if len(ctx.Args()) > 0 {
				output = strings.TrimSuffix(ctx.Args()[0], ".go") + "_bin2var.go"
				source = ctx.Args()[0]
			} else if os.Getenv("GOFILE") != "" {
				output = strings.TrimSuffix(os.Getenv("GOFILE"), ".go") + "_bin2var.go"
				source = os.Getenv("GOFILE")
			}
		} else {
			source = os.Getenv("GOFILE")
		}
		bink := make([]string, 0)
		binv := make([]string, 0)
		extractall(inputs, &bink, &binv)
		//
		if args.Package == "" {
			args.Package = os.Getenv("GOPACKAGE")
		}
		fmt.Println("bin2var PACKAGE", args.Package)

		ef, err := os.OpenFile(output, os.O_WRONLY|os.O_TRUNC|os.O_CREATE, 0644)
		if err != nil {
			return err
		}
		defer ef.Close()
		eb := bufio.NewWriter(ef)
		eb.WriteString("// Code generated by bin2var <https://github.com/gabstv/bin2var>. DO NOT EDIT.\n")
		eb.WriteString("// source: ")
		eb.WriteString(source)
		eb.WriteString("\n\npackage ")
		eb.WriteString(args.Package)
		eb.WriteString("\n\n")
		for k := range bink {
			eb.WriteString(fmt.Sprintf("var %s = []byte(\"%s\")\n", bink[k], binv[k]))
		}
		eb.Flush()
		return nil
	})
}

func extractall(inputfiles []string, mk, mv *[]string) {
	for _, fname := range inputfiles {
		fp, err := os.Open(fname)
		if err != nil {
			log.Println("could not open", fname, err.Error())
			continue
		}
		bufw := new(bytes.Buffer)
		bufr := bufio.NewReader(fp)
		for {
			lastByte, err := bufr.ReadByte()
			if err != nil {
				break
			}
			bufw.WriteString(fmt.Sprintf("\\x%02x", lastByte))
		}
		*mk = append(*mk, nicename(fname))
		*mv = append(*mv, bufw.String())
	}
}

func nicename(v string) string {
	outp := new(bytes.Buffer)
	nextUpper := false
	firstCharOK := false
	for _, r := range v {
		if !firstCharOK {
			if r > 0x40 && r < 0x5b {
				// + 32 = to lower
				outp.WriteRune(r + 32)
				firstCharOK = true
			} else if r > 0x60 && r < 0x7b {
				outp.WriteRune(r)
				firstCharOK = true
			} else if r > 0x2f && r < 0x3a {
				outp.WriteRune('_')
				outp.WriteRune(r)
				firstCharOK = true
			}
		} else {
			if r > 0x40 && r < 0x5b {
				outp.WriteRune(r)
			} else if r > 0x60 && r < 0x7b {
				if nextUpper {
					outp.WriteRune(r - 32)
					nextUpper = false
				} else {
					outp.WriteRune(r)
				}
			} else {
				nextUpper = true
			}
		}
	}
	return outp.String()
}
